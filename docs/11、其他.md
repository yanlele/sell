## 其他部分

1、异常处理 `SellExceptionHandler`

2、添加mybatis                         
依赖                              
```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>1.2.0</version>
</dependency>
```


注解式添加mybatis `ProductCategoryMapper`                           

测试 `ProductCategoryMapperTest`

测试跑不通， 是因为没有写配置， 需要一些配置 `SellApplication` 添加注解 `@MapperScan(basePackages = "com.imooc.dataobject.mapper")`

使用可以看 `ProductCategoryDao` 就OK

如果希望看到mybatis 的日志 可以在yml 文件中做如下配置
```yaml
logging:
  level: 
    com.imooc.dataobject.mapper: trace
```

3、mybatis 写在 xml 的方式                                
`ProductCategoryMapper` --> `ProductCategoryMapper.xml`  -->  `SeckillController`

4、压测工具 `appach ab`
`ab -n 100 -c 100 http://127.0.0.1:8080/sell/seckill/order/123456` -> 表示十个线程 总共一百个请求


4.5、模拟一个高并发的环境                          
`SeckillService` -->  `SeckillServiceImpl` -->  `SeckillController`

启动项目之后访问秒杀接口 `127.0.0.1:8080/sell/seckill/order/123456`


5、使用`synchronized`解决并发问题。强制单线程处理问题                          
- 无法做到细腻度的控制
- 只适合单点的情况
```java
@Service
public class SeckillServiceImpl implements SeckillService {

    static Map<String , Integer> products;
    static Map<String , Integer> stock;
    static Map<String , String> orders;
    static {
        products = new HashMap<>();
        stock = new HashMap<>();
        orders = new HashMap<>();
        products.put("123456", 100000);
        stock.put("123456", 100000);
    }

    @Override
    public String queryMap(String productId) {
        return "国庆节活动， 限量："
                + products.get(productId)
                + "  还剩："
                + stock.get(productId) + " 份"
                + " 该商品成功下单用户数目: "
                + orders.size() + " 人";
    }

    @Override
    public String querySecKillProductInfo(String productId) {
        return this.queryMap(productId);
    }

    @Override
    public synchronized void orderProductMockDiffUser(String productId) {
        // 查询该商品库存为0 结束活动
        int stockNum = stock.get(productId);
        if (stockNum == 0 ) {
            throw new SellException(100, "活动结束");
        } else {
            // 下单
            orders.put(KeyUtil.genUniqueKey(), productId);
            // 减库存
            stockNum = stockNum - 1;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            stock.put(productId, stockNum);
        }
    }
}
```

6、redis 的锁 `SETNX`、`getset`                             
加锁的核心代码 `RedisLock` -->  `SeckillController`

7、redis 缓存                      
命中、失效、更新

首先要在启动的时候添加缓存注解
```java
@SpringBootApplication
@MapperScan(basePackages = "com.imooc.dataobject.mapper")
@EnableCaching
public class SellApplication {

	public static void main(String[] args) {
		SpringApplication.run(SellApplication.class, args);
	}
}
```

在需要缓存的方法上面添加这个 `@Cacheable(cacheNames = "product", key = "123")` 和 `@CacheEvict(cacheNames = "product", key = "123")`                         
这个地方以 `BuyerProductController  -  list` 和 `SellerProductController  -  save` 为例


然后在方法返回对象上面添加 `Serializable` ， 这个时候可以考虑下载一个插件 `GenerateSerialVersionUID` 然后配置一个快捷OK了。
把所有的vo 对象都加上 `Serializable`  这个是因为需要在缓存的时候有唯一索引



